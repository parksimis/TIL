# Array indexing

> 슬라이싱(Slicing) 
>
> * 파이썬 리스트와 유사하게 배열도 슬라이싱이 가능하다. 
> * ndarray는 다차원 배열이므로 각 차원에 대해 슬라이싱을 할 수 있다.



```python
# shape가 (3, 4)이고, 아래와 같은 값을 갖는 2차원 배열을 생성

>>> a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])
>>> b = a[:2, 1:3]
>>> print(b)
[[2 3]
 [6 7]]
```

* **주의할 점**

  * 배열의 슬라이스를 잘라서 만든 배열은, 원래의 배열과 값을 **<u>공유</u>**하므로 수정할 경우 원래의 배열도 값이 변경된다!!

  ```python
  >>> print(a[0, 1])
  2
  
  >>> b[0, 0] = 77 
  >>> print(b)
  [[77  3]
   [ 6  7]]
  
  >>> print(a)
  [[ 1 77  3  4]
   [ 5  6  7  8]
   [ 9 10 11 12]]
  ```

* 만일 값을 복사해서 새로운 배열을 만들고 싶으면, `copy()`함수를 사용한다.

  ```python
  >>> c = b.copy()
  >>> c[0, 0] = 55
  >>> print(c)
  [[55  3]
   [ 6  7]]
  >>> print(b)
  [[77  3]
   [ 6  7]]
  ```

* 인덱싱과 슬라이싱을 섞어서 쓸 수 있다. (정확히는 정수 indexing과 슬라이스 indexing)

  ```python
  >>> a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])
  >>> print(a, a.shape)
  [[ 1  2  3  4]
   [ 5  6  7  8]
   [ 9 10 11 12]] (3, 4)
  ```

* 정수 인덱싱과 슬라이싱을 섞어 쓰는 경우, 차원이 감소할 수 있다. (슬라이싱만 쓰는 경우에는 차원이 유지됨)

  ```python
  # 차원 감소
  >>> row_r1 = a[1, :] 
  >>> print(row_r1, row_r1.shape)
  [5 6 7 8] (4,)
  
  # 차원 유지
  >>> row_r2 = a[1:2, :] 
  >>> print(row_r2, row_r2.shape)
  [[5 6 7 8]] (1, 4)
  
  # 차원 감소
  >>> row_r3 = a[2, :]
  >>> print(row_r3, row_r3.shape)
  [ 9 10 11 12] (4,)
  
  # 컬럼만 잘라내는 경우도 마찬가지
  >>> col_r1 = a[:, 1]
  >>> col_r2 = a[:, 1:2]
  >>> print(col_r1, col_r1.shape)
  [ 2  6 10] (3,)
  >>> print(col_r2, col_r2.shape)
  [[ 2]
   [ 6]
   [10]] (3, 1)
  ```

* 정수 배열을 이용한 인덱싱

  * 슬라이싱을 사용하는 경우, 결과는 항상 원래 배열의 서브 배열이 된다. 
  * 반면, 정수 배열을 이용하면, 임의로 변경하는 것이 가능하다.

  ```python
  >>> a = np.array([[1,2], [3, 4], [5, 6]])
  >>> print(a, a.shape)
  [[1 2]
   [3 4]
   [5 6]] (3, 2)
  # 정수 배열 인덱싱의 예.
  # 반환된 배열의 shape는 (3,) 
  >>> print(a[[0, 1, 2], [0, 1, 0]])
  [1 4 5]
  # 위 방식은 아래 방식과 동일한 결과를 만들어 냄:
  >>> print(np.array([a[0, 0], a[1, 1], a[2, 0]]))
  [1 4 5]
  ```

  * 정수 배열 인덱싱은 각각의 행/열에서 원하는 요소만 가져오고 싶을 때 유용하게 사용이 가능하다.

  ```python
  
  ```

  

