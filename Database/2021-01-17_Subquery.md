# SubQuery

* 간단히 말하면, 쿼리문 안에 또 쿼리문이 들어 있는 것.
* SELECT 문 안에 또 다들 SELECT 문을 포함하는 질의문
  * 상위 질의문(주 질의) : 다른 SELECT 문을 포함하는 SELECT 문
  * 부속 질의문(부속 질의) : 다른 SELECT 안에 들어있는 SELECT 문\
    * 괄호로 묶어서 작성하고, ORDER BY 절을 사용할 수 없다.
    * 단일행 부속질의 : 하나의 행을 결과로 반환한다.
    * 다중행 부속질의 : 하나 이상의 행을 결과로 반환한다.
* 부속질의가 먼저 실행되고, 그 결과를 바탕으로 상위질의문이 실행된다.
* 따라서 부속질의문과 상위질의문을 연결하는 연산자가 필요하다.
  * 단일행 부속질의는 비교연산자 사용이 가능함.
  * 다중행 부속질의는 비교연산자 사용이 불가하다.



## 1. 단일행 부속질의

1. 판매 데이터베이스에서 '달콤비스킷'을 생산한 제조업체가 만든 제품들의 제품명과 단가를 확인하라

   * 위의 경우, 두 개의 쿼리를 연결 시켜야한다.

   Query 1) '달콤비스킷'을 만든 업체를 찾는다.(한빛제과) -> 부속질의

   Query 2) Query 1의 결과를 가지는 제품명의 단가를 반환한다. -> 상위질의

   ```mysql
   -- Step 1) 달콤비스킷을 만든 업체를 찾는다.
   MariaDB [판매]> (SELECT 제조업체
       -> FROM 제품
       -> WHERE 제품명 = '달콤비스킷');
   +----------+
   | 제조업체 |
   +----------+
   | 한빛제과 |
   +----------+
   1 row in set (0.001 sec)
   
   -- Step 2) 서브쿼리로 작성하기
   MariaDB [판매]> SELECT 제품명, 단가
       -> FROM 제품
       -> WHERE 제조업체 = (SELECT 제조업체
       -> FROM 제품
       -> WHERE 제품명 = '달콤비스킷');
   +------------+------+
   | 제품명     | 단가 |
   +------------+------+
   | 쿵떡파이   | 2860 |
   | 맛난초콜릿 | 2750 |
   | 달콤비스킷 | 1650 |
   +------------+------+
   3 rows in set (0.000 sec)
   ```

   

2. 판매 데이터베이스에서 적립금이 가장 많은 고객 이름과 적립금을 검색하라.

   Query 1) 고객 테이블에서 가장 큰 적립근을 추출

   Query 2) Query 1)의 결과를 가지는 고객이름과 적립금을 검색

   ```mysql
   -- 이렇게 사용하면 안됨!!
   -- 집계함수와 일반속성을 사용했기때문에, 실행은 되지만, 논리적 오류 발생
   -- 아래의 서브쿼리 결과와 비교해보자
   
   MariaDB [판매]> SELECT 고객이름, MAX(적립금)
       -> FROM 고객;
   +----------+-------------+
   | 고객이름 | MAX(적립금) |
   +----------+-------------+
   | 정소화   |        5000 |
   +----------+-------------+
   1 row in set (0.001 sec)
   
   
   -- 서브쿼리 문 작성
   MariaDB [판매]> SELECT 고객이름, 적립금
       -> FROM 고객
       -> WHERE 적립금 = (SELECT max(적립금) FROM 고객);
   +----------+--------+
   | 고객이름 | 적립금 |
   +----------+--------+
   | 성원용   |   5000 |
   +----------+--------+
   1 row in set (0.000 sec)
   ```

   * 위의 잘못된 예시와 비교로 알 수 있듯이, 적립금이 가장 많은 고객은 '성원용' 고객이지만, 위의 잘못된 예시는 '정소화'로 나온 것을 알 수 있다. 
   * 이는 집계함수와 일반속성을 동시에 사용해서 고객 테이블의 가장 처음 나오는 고객이름을 그냥 반환시켜줘 논리적인 오류를 발생시킨 것을 알 수 있다.



## 2. 다중행 부속질의

* 다중행 부속 질의문에 사용 가능한 연산자
  * IN / NOT IN / EXISTS / NOT EXISTS / ALL / ANY / SOME

* 'banana' 고객이 주문한 제품의 제품명과 제조업체를 반환하시오.

* 이 쿼리의 경우, 

  * Query 1) 'banana'가 주문한 제품을 확인
  * Query 2) Query 1)의 결과의 제품명과 제조업체 반환
  * 으로 나눌 수 있다.

  ```mysql
  MariaDB [판매]> SELECT 제품명, 제조업체
      -> FROM 제품
      -> WHERE 제품번호 = (SELECT 주문제품
      -> FROM 주문
      -> WHERE 주문고객 = 'banana');
  ERROR 1242 (21000): Subquery returns more than 1 row
  ```

  * 단일행 부속질의 형태로 작성한 결과 '서브쿼리의 반환 행이 2개 이상이라는 에러 메시지가 뜬다.'
  * 이 경우에는 다중행 부속질의를 사용해야 한다.

### 1) IN

* 위의 오류나는 쿼리를 IN 연산자를 통해 해결할 수 있다.

```mysql
MariaDB [판매]> SELECT 제품명, 제조업체
    -> FROM 제품
    -> WHERE 제품번호 IN
    -> (SELECT 주문제품
    -> FROM 주문
    -> WHERE 주문고객 = 'banana');
+------------+----------+
| 제품명     | 제조업체 |
+------------+----------+
| 그냥만두   | 대한식품 |
| 맛난초콜릿 | 한빛제과 |
| 통통우동   | 민국푸드 |
+------------+----------+
3 rows in set (0.001 sec)
```



### 2) NOT IN

* IN 연산자와 반대의 의미를 가진다.

* 적용 예시

  * 판매 데이터베이스에서 'banana' 고객이 주문하지 않은 제품명과 제조업체를 확인하라.
  * Query 1) banana 고객이 주문한 제품을 추출한다.
  * Query 2) Query 1)의 결과가 아닌 제품에 대해서 출력한다.

  ```mysql
  MariaDB [판매]> SELECT 제품명, 제조업체
      -> FROM 제품
      -> WHERE 제품번호 NOT IN
      -> (SELECT 주문제품
      -> FROM 주문
      -> WHERE 주문고객 = 'banana')
      -> ;
  +------------+----------+
  | 제품명     | 제조업체 |
  +------------+----------+
  | 매운쫄면   | 민국푸드 |
  | 쿵떡파이   | 한빛제과 |
  | 얼큰라면   | 대한식품 |
  | 달콤비스킷 | 한빛제과 |
  +------------+----------+
  4 rows in set (0.001 sec)
  ```

  

### 3) ALL

* 부속질의가 반환하는 값의 비교연산자를 모두 만족하는 값

* 적용 예제

  * 판매 데이터베이스에서 대한식품이 제조한 모든 제품의 단가보다 비싼 제품의 제품명, 단가, 제조업체를 검색하라
  * Query 1) 대한식품에서 제조한 제품의 단가를 검색한다.
  * Query 2) Query 1)의 결과보다 모두 큰 제품의 제품명, 단가, 제조업체를 검색한다.

  ```mysql
  -- 1) 대한식품의 제품 단가를 검색한다.
  MariaDB [판매]> SELECT 단가
      -> FROM 제품
      -> WHERE 제조업체 = '대한식품'
      -> ;
  +------+
  | 단가 |
  +------+
  | 4950 |
  | 1320 |
  +------+
  2 rows in set (0.000 sec)\
  
  -- 2) 4950보다 커야한다.
  -- MAX()를 사용해도 되지만, ALL 연산자 연습을 위해 ALL을 사용한다.
  MariaDB [판매]> SELECT 제품명, 단가, 제조업체
      -> FROM 제품
      -> WHERE 단가 > ALL(SELECT 단가
      -> FROM 제품
      -> WHERE 제조업체 = '대한식품')
      -> ;
  +----------+------+----------+
  | 제품명   | 단가 | 제조업체 |
  +----------+------+----------+
  | 매운쫄면 | 6050 | 민국푸드 |
  +----------+------+----------+
  1 row in set (0.000 sec)
  ```

  

### 4) ANY

* 부속질의가 반환하는 값의 비교연산자를 하나라도 만족하는 값

* 적용 예제

  * 위의 ALL에 대한 질의에 ANY를 적용한다면?

  ```mysql
  MariaDB [판매]> SELECT 제품명, 단가, 제조업체
      -> FROM 제품
      -> WHERE 단가 > ANY(SELECT 단가
      -> FROM 제품
      -> WHERE 제조업체 = '대한식품')
      -> ;
  +------------+------+----------+
  | 제품명     | 단가 | 제조업체 |
  +------------+------+----------+
  | 그냥만두   | 4950 | 대한식품 |
  | 매운쫄면   | 6050 | 민국푸드 |
  | 쿵떡파이   | 2860 | 한빛제과 |
  | 맛난초콜릿 | 2750 | 한빛제과 |
  | 통통우동   | 1705 | 민국푸드 |
  | 달콤비스킷 | 1650 | 한빛제과 |
  +------------+------+----------+
  6 rows in set (0.000 sec)
  ```

  * 1320 또는 4950보다 높은 단가를 가지는 제품명, 단가, 제조업체가 추출된다.



### 5) EXISTS / NOT EXISTS

* EXISTS : 부속질의문의 결과값이 하나라도 존재하면,

* NOT EXISTS : 부속질의문의 결과값이 하나도 존재하지 않으면

* 적용 예제

  1. EXISTS
     * 판매 데이터베이스에서 2019년 3월 02일에 제품을 주문한 고객의 고객이름을 검색

  ```mysql
  -- STEP 1) 2019년 3월 2일에 제품을 주문한 고객 검색
  MariaDB [판매]> SELECT *
      -> FROM 주문
      -> WHERE 주문일자='2019-03-02';ㅣ
  +----------+----------+----------+------+-----------------+------------+
  | 주문번호 | 주문고객 | 주문제품 | 수량 | 배송지          | 주문일자   |
  +----------+----------+----------+------+-----------------+------------+
  | o06      | banana   | p01      |   19 | 충청북도 보은군 | 2019-03-02 |
  +----------+----------+----------+------+-----------------+------------+
  1 row in set (0.000 sec)
  
  -- STEP 2) 주문고객 필드 값을 이용해서 고객테이블에서 이름을 확인한다.
  MariaDB [판매]> SELECT 고객이름
      -> FROM 고객
      -> WHERE EXISTS (SELECT *
      -> FROM 주문
      -> WHERE 주문일자 = '2019-03-02' AND
      -> 주문.주문고객 = 고객.고객아이디)
      -> ;
  +----------+
  | 고객이름 |
  +----------+
  | 김선우   |
  +----------+
  1 row in set (0.000 sec)
  ```

  	2. 판매 데이터베이스에서 2019년 3월 2일에 제품을 **'주문하지 않은'** 고객의 고객이름을 검색

  ```mysql
  MariaDB [판매]> SELECT 고객이름
      -> FROM 고객
      -> WHERE NOT EXISTS (SELECT *
      -> FROM 주문
      -> WHERE 주문일자 = '2019-03-02' AND
      -> 주문.주문고객 = 고객.고객아이디)
      -> ;
  +----------+
  | 고객이름 |
  +----------+
  | 정소화   |
  | 고명석   |
  | 성원용   |
  | 김용욱   |
  | 오형준   |
  | 채광주   |
  | 최유경   |
  | 정은심   |
  +----------+
  8 rows in set (0.000 sec)
  ```

  * 위의 EXISTS의 결과인 2019년 3월 2일에 제품을 주문한 '김선우'를 제외한 모든 고객 이름이 반환된다.