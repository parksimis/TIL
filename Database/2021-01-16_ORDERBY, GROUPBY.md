# SQL을 이용한 데이터 조작


## 1. ORDER BY

* ORDER BY 절은 결과물에 대해 영향을 미치지는 않지만, 결과가 출력되는 순서를 조절하는 구문이다.

* 기본 구문

  ```sql
  SELECT 속성_리스트
  FROM 테이블_리스트
  [WHERE 조건]
  [ORDER BY 속성_리스트] [ASC | DESC]
  ```

  * `ASC` : 오름차순(Default)
  * `DESC` : 내림차순
    * NULL 값 처리 : ASC(오름차순) 맨 먼저 출력, DESC(내림차순)에서는 맨 마지막에 출력됨
  * 실행 순서는 FROM -> WHERE -> SELECT -> ORDER BY 순으로 실행된다.
  * ORDER BY 절은 SQL 쿼리문의 가장 마지막에 위치해야 한다.



### - 적용 예제

1. 고객 테이블에서 고객이름, 등급, 나이를 검색하되, 나이를 기준으로 내림차순 정렬

   ```mysql
   MariaDB [판매]> SELECT 고객이름, 등급, 나이
       -> FROM 고객
       -> ORDER BY 나이 DESC;
   +----------+--------+------+
   | 고객이름 | 등급   | 나이 |
   +----------+--------+------+
   | 성원용   | gold   |   35 |
   | 채광주   | silver |   31 |
   | 고명석   | gold   |   28 |
   | 김선우   | vip    |   25 |
   | 김용욱   | silver |   22 |
   | 정소화   | gold   |   20 |
   | 오형준   | silver | NULL |
   +----------+--------+------+
   7 rows in set (0.000 sec)
   
   -- NULL이 가장 마지막에 출력됨
   
   -- 오름차순 정렬하는 경우
   MariaDB [판매]> SELECT 고객이름, 등급, 나이
       -> FROM 고객
       -> ORDER BY 3 ASC;
   +----------+--------+------+
   | 고객이름 | 등급   | 나이 |
   +----------+--------+------+
   | 오형준   | silver | NULL |
   | 정소화   | gold   |   20 |
   | 김용욱   | silver |   22 |
   | 김선우   | vip    |   25 |
   | 고명석   | gold   |   28 |
   | 채광주   | silver |   31 |
   | 성원용   | gold   |   35 |
   +----------+--------+------+
   7 rows in set (0.000 sec)
   --  NULL 값이 가장 먼저 출력
   ```

2. 주문 테이블에서 수량이 10개 이상인 주문의 주문고객, 주문제품, 수량, 주문일자를 검색

   * 단, 주문제품을 기준으로 오름차순 정렬하고, 동일제품을 수량을 기준으로 내림차순 정렬하라

   ```mysql
   MariaDB [판매]> SELECT 주문고객, 주문제품, 수량, 주문일자
       -> FROM 주문
       -> WHERE 수량 >= 10
       -> ORDER BY 주문제품 ASC, 수량 DESC;
   +----------+----------+------+------------+
   | 주문고객 | 주문제품 | 수량 | 주문일자   |
   +----------+----------+------+------------+
   | banana   | p01      |   19 | 2019-03-02 |
   | pear     | p02      |   50 | 2019-04-10 |
   | apple    | p03      |   22 | 2019-03-15 |
   | carrot   | p03      |   20 | 2019-05-22 |
   | apple    | p03      |   10 | 2019-01-01 |
   | banana   | p04      |   15 | 2019-04-11 |
   | banana   | p06      |   45 | 2019-01-11 |
   | melon    | p06      |   36 | 2019-02-20 |
   +----------+----------+------+------------+
   8 rows in set (0.000 sec)
   
   ```

   - 기본적으로 주문제품을 기준으로 오름차순 정렬하지만,  동일한 경우에는 수량을 기준으로 내림차순으로 정렬된다.

## 2. GROUP BY 및 HAVING

* 기본 형식

  ```sql
  SELECT select_expr
  	[FROM table_reference]
  	[WHERE where_condition]
  	[GROUP BY {col_name | expr | position}]
  	[HAVING where_condition]
  	[ORDER BY {col_name | expr | position}]
  ```

* `GROUP BY`는 말 그대로 그룹을 묶어주는 역할을 한다.
* `HAVING`은 `WHERE`와 비슷한 개념으로 조건을 제한하는 것이지만, 집계 함수에 대해서 조건을 제한하는 것. 
  * `HAVING`절은 꼭 `GROUP BY`절 다음에 나와야 한다.
* 그룹을 나누는 기준이 되는 속성은 SELECT 절에도 작성하는 것이 좋다.

#### - 집계함수

* GROUP BY 절과 자주 사용되는 것이 집계함수이다.

* 특정 속성값을 통계적으로 계산한 결과를 검색한다.

* NULL 값은 제외하고 계산한다.

* WHERE 절에서는 사용할 수 없고, SELECT 절이나 HAVING 절에서만 사용 가능하다.

* 종류

  | 함수명          | 설명                               |
  | --------------- | ---------------------------------- |
  | SUM()           | 합계                               |
  | AVG()           | 평균                               |
  | MIN()           | 최솟값                             |
  | MAX()           | 최댓값                             |
  | COUNT()         | 행의 개수를 셈.                    |
  | COUNT(DISTINCT) | 행의 개수를 셈.(중복은 1개만 인정) |
  | STDEV()         | 표준편차를 구함.                   |
  | VAR_SAMP()      | 분산을 구함.                       |

### - 적용 예제

#### 1) `AVG()`

* 제품 테이블에서 단가 필드를 추출하고 평균함수를 적용

  ```mysql
  MariaDB [판매]> SELECT AVG(단가)
      -> FROM 제품;
  +-----------+
  | AVG(단가) |
  +-----------+
  | 2764.2857 |
  +-----------+
  1 row in set (0.000 sec)
  ```

#### 2) `SUM()`

* 한빛 제과에서 제조한 제품의 재고량 합계를 제품 테이블에서 확인

* 단, 이름은 재고량 합계로 변경해서 추출하라

  ```mysql
  MariaDB [판매]> SELECT SUM(재고량) AS '재고량합계'
      -> FROM  제품
      -> WHERE 제조업체 = '한빛제과';
  +------------+
  | 재고량합계 |
  +------------+
  |       6500 |
  +------------+
  1 row in set (0.000 sec)
  ```

#### 3) `COUNT()`

* 고객 테이블에 고객이 몇 명 등록되어 있는지 확인하라

  ```mysql
  -- 1) 고객아이디 속성의 행 수를 COUNT
  MariaDB [판매]> SELECT COUNT(고객아이디) AS 고객수
      -> FROM 고객;
  +--------+
  | 고객수 |
  +--------+
  |      7 |
  +--------+
  1 row in set (0.000 sec)
  
  
  -- 2) 나이 속성의 행 수를 COUNT
  MariaDB [판매]> SELECT COUNT(나이) AS 고객수
      -> FROM 고객;
  +--------+
  | 고객수 |
  +--------+
  |      6 |
  +--------+
  1 row in set (0.000 sec)
  
  -- 3) 전체 열의 행 수를 반환
  MariaDB [판매]> SELECT COUNT(*) AS 고객수
      -> FROM 고객;
  +--------+
  | 고객수 |
  +--------+
  |      7 |
  +--------+
  1 row in set (0.000 sec)
  ```

  * 나이 속성을 기준으로 행 수를 COUNT한 경우, NULL 값은 제외하고 행의 개수를 세기 때문에, 1), 3)과는 다른 6개의 숫자를 반환하는 것을 볼 수 있다.
  * 따라서 정확한 개수를 계산하기 위해서는 기본키 속성이나 *를 주로 이용한다.

#### 4) 중복을 제거한 집계함수 적용

* 제품을 제조하는 거래처에 대해 몇개의 업체와 거래하고 있는지 확인

  ```mysql
  -- DISTINCT 옵션 사용 X
  MariaDB [판매]> SELECT COUNT(제조업체) AS '제조업체 수'
      -> FROM 제품;
  +-------------+
  | 제조업체 수 |
  +-------------+
  |           7 |
  +-------------+
  1 row in set (0.000 sec)
  
  -- DiSTINCT 옵션 사용 O
  MariaDB [판매]> SELECT COUNT(DISTINCT 제조업체) AS '제조업체 수'
      -> FROM 제품;
  +-------------+
  | 제조업체 수 |
  +-------------+
  |           3 |
  +-------------+
  1 row in set (0.000 sec)
  ```

  * `DISTINCT`를 통해 중복을 제거한 행의 개수를 반환받을 수 있다.

#### 5) `GROUP BY , HAVING`

1. 주문 테이블에서 주문 제품별 수량의 합계를 확인

   ```mysql
   -- GROUP BY 사용 X
   MariaDB [판매]> SELECT * FROM 주문;
   +----------+----------+----------+------+-----------------+------------+
   | 주문번호 | 주문고객 | 주문제품 | 수량 | 배송지          | 주문일자   |
   +----------+----------+----------+------+-----------------+------------+
   | o01      | apple    | p03      |   10 | 서울시 마포구   | 2019-01-01 |
   | o02      | melon    | p01      |    5 | 인천시 계양구   | 2019-01-10 |
   | o03      | banana   | p06      |   45 | 경기도 부천시   | 2019-01-11 |
   | o04      | carrot   | p02      |    8 | 부산시 금정구   | 2019-02-01 |
   | o05      | melon    | p06      |   36 | 경기도 용인시   | 2019-02-20 |
   | o06      | banana   | p01      |   19 | 충청북도 보은군 | 2019-03-02 |
   | o07      | apple    | p03      |   22 | 서울시 영등포구 | 2019-03-15 |
   | o08      | pear     | p02      |   50 | 강원도 춘천시   | 2019-04-10 |
   | o09      | banana   | p04      |   15 | 전라남도 목포시 | 2019-04-11 |
   | o10      | carrot   | p03      |   20 | 경기도 안양시   | 2019-05-22 |
   +----------+----------+----------+------+-----------------+------------+
   10 rows in set (0.000 sec)
   
   
   -- GROUP BY 사용
   -- 각 주문제품별 수량의 합계를 확인할 수 있다.
   MariaDB [판매]> SELECT 주문제품, SUM(수량)
       -> FROM 주문
       -> GROUP BY 주문제품 ;
   +----------+-----------+
   | 주문제품 | SUM(수량) |
   +----------+-----------+
   | p01      |        24 |
   | p02      |        58 |
   | p03      |        52 |
   | p04      |        15 |
   | p06      |        81 |
   +----------+-----------+
   5 rows in set (0.000 sec)
   
   
   -- 논리적 오류의 예시
   MariaDB [판매]> SELECT 주문제품, 주문고객, SUM(수량) AS 총주문수량
       -> FROM 주문
       -> GROUP BY 주문제품 ;
   +----------+----------+------------+
   | 주문제품 | 주문고객 | 총주문수량 |
   +----------+----------+------------+
   | p01      | melon    |         24 |
   | p02      | carrot   |         58 |
   | p03      | apple    |         52 |
   | p04      | banana   |         15 |
   | p06      | banana   |         81 |
   +----------+----------+------------+
   5 rows in set (0.000 sec)
   
   ```

   * SELECT에 그룹의 기준이 되는 필드 외에 다른 필드를 작성하면, 그룹의 여러 필드값 중 가장 위에 있는 값이 임의 추출되어 논리적 오류를 일으킨다.

     * 따라서 GROUP BY 연산 시에는 기준 필드외에 일반 필드는 집계함수를 사용하거나 표현하지 않는다.

       

2. 제품 테이블에서 제조업체 별로 제조한 제품의 개수와 제품 중 가장 비싼 단가를 확인

   * 제품의 개수는 제품 수라는 이름으로 줄력하고, 가장 비싼 단가는 최고가라는 이름으로 출력하라

   ```mysql
   MariaDB [판매]> SELECT 제조업체, COUNT(*) AS '제품 수', MAX(단가) AS 최고가
       -> FROM 제품
       -> GROUP BY 제조업체 ;
   +----------+---------+--------+
   | 제조업체 | 제품 수 | 최고가 |
   +----------+---------+--------+
   | 대한식품 |       2 |   4500 |
   | 민국푸드 |       2 |   5500 |
   | 한빛제과 |       3 |   2600 |
   +----------+---------+--------+
   3 rows in set (0.000 sec)
   ```

3. 제품 테이블에서 제품을 3개 이상 제조한 제조업체별로 제품의 개수, 제품 중 가장 비싼 단가를 검색하라

   ```mysql
   MariaDB [판매]> SELECT 제조업체, COUNT(*) AS '제품 수', MAX(단가) AS 최고가
       -> FROM 제품
       -> GROUP BY 제조업체
       -> HAVING COUNT(*) >= 3 ;
   +----------+---------+--------+
   | 제조업체 | 제품 수 | 최고가 |
   +----------+---------+--------+
   | 한빛제과 |       3 |   2600 |
   +----------+---------+--------+
   1 row in set (0.000 sec)
   ```

   * GROUP 별로 적용해야 하는 조건은 HAVING 절에 기재한다.



